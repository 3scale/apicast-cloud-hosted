local iputils = require("resty.iputils")
local default_balancer = require('resty.balancer.round_robin').call
local resty_balancer = require('resty.balancer')
local prometheus = require('apicast.prometheus')
local split = require('ngx.re').split
local tonumber = tonumber
local setmetatable = setmetatable

local _M = require('apicast.policy').new('IP Blacklist', '0.1')
local mt = { __index = _M }

local ipv4 = {
  unspecified = { '0.0.0.0/8' },
  broadcast = { '255.255.255.255/32' },
  multicast = { '224.0.0.0/4' },
  linkLocal = { '169.254.0.0/16' },
  loopback = { '127.0.0.0/8' },
  private = { '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16' },
  reserved = { '192.0.0.0/24' }
}

local whitelist = iputils.parse_cidrs(split(os.getenv('APICAST_BALANCER_WHITELIST') or '', ','))
local blacklist = {}

for _,cidrs in pairs(ipv4) do
  local list = iputils.parse_cidrs(cidrs)

  for i=1,#list do
    table.insert(blacklist, list[i])
  end
end

function _M.new()
  return setmetatable({}, mt)
end

function _M:init()
  iputils.enable_lrucache()
end

local function whitelisted(ip)
  local whitelisted = iputils.ip_in_cidrs(ip, whitelist)

  if whitelisted then
    return true
  end

  local blacklisted, err = iputils.ip_in_cidrs(ip, blacklist)

  return not blacklisted, err
end

local balancer_metric = prometheus('counter', 'cloud_hosted_balancer', 'Cloud hosted balancer', {'status'})
local upstream_metric = prometheus('counter', "upstream_status", "HTTP status from upstream servers", {"status"})
local proxy_status_metric = prometheus('counter', "apicast_status", "HTTP status generated by APIcast", {"status"})

local metric_labels = {}

local function increment(metric, label)
  if not metric then return end
  metric_labels[1] = label -- do not allocate new table for every increment but reuse one

  metric:inc(1, metric_labels)
end

local balancer_with_blacklist = resty_balancer.new(function(peers)
  local peer, i = default_balancer(peers)

  if not peer then
    return nil, i
  end

  local ip = peer[1]

  local allowed, err = whitelisted(ip)

  if not allowed then
    increment(balancer_metric, 'blacklisted')
    return nil, 'blacklisted'
  elseif err then
    increment(balancer_metric, err)
    return nil, err
  else
    return peer, i
  end
end)

function _M:balancer()
  local balancer = balancer_with_blacklist
  local host = ngx.var.proxy_host -- NYI: return to lower frame
  local peers = balancer:peers(ngx.ctx[host])

  local peer, err = balancer:set_peer(peers)

  if not peer then
    ngx.status = ngx.HTTP_SERVICE_UNAVAILABLE
    ngx.log(ngx.ERR, "failed to set current backend peer: ", err)
    ngx.exit(ngx.status)
  else
    increment(balancer_metric, 'success')
  end
end

local status_map = setmetatable({
  -- http://mailman.nginx.org/pipermail/nginx/2013-May/038773.html
  [9] = 499,
}, { __index = function(_, k) return tonumber(k) end })

function _M.log()
  local upstream_status = tonumber(ngx.var.upstream_status)

  if upstream_status then
    increment(upstream_metric, upstream_status)
  else
    increment(proxy_status_metric, status_map[ngx.status])
  end
end

return _M
